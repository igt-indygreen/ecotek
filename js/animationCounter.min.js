!function(a){a.fn.animationCounter=function(b){return this.each(function(){try{var c=a(this),d={start:0,end:null,step:1,delay:1e3,txt:""},e=a.extend(d,b||{}),f=e.start,g=e.end;c.text(f+e.txt);var h=function(){null!=g&&f>=g||(f+=e.step,c.text(f+e.txt))};setInterval(h,e.delay)}catch(a){alert(a+" at line "+a.lineNumber)}})}}(jQuery);

(function(){
  const slidesEl = document.getElementById('slides');
  const slideEls = Array.from(slidesEl.children);
  const indicatorsContainer = document.getElementById('indicators');
  const nextBtn = document.getElementById('nextBtn');
  const prevBtn = document.getElementById('prevBtn');
  const viewport = document.getElementById('heroViewport');

  const conf = { autoplay:true, interval:4500, pauseOnHover:true, keyboard:true, startIndex:0, loop:true, touch:true };
  let index = Math.min(conf.startIndex, slideEls.length-1);
  let timer = null, startX=0, deltaX=0;

  slideEls.forEach((s,i)=>{
    const btn = document.createElement('button');
    btn.className = 'dot';
    btn.type='button';
    btn.setAttribute('aria-pressed','false');
    btn.setAttribute('aria-label', `Go to slide ${i+1}`);
    btn.addEventListener('click', ()=> goTo(i));
    indicatorsContainer.appendChild(btn);
  });
  const dots = Array.from(indicatorsContainer.children);

  function render(){
    slidesEl.style.transform = `translateX(-${index * 100}%)`;
    dots.forEach((d,i)=> d.setAttribute('aria-pressed', String(i===index)));
    slideEls.forEach((s,i)=> s.setAttribute('aria-hidden', String(i !== index)));
  }

  function next(){ index = (index + 1) % slideEls.length; render(); }
  function prev(){ index = (index - 1 + slideEls.length) % slideEls.length; render(); }
  function goTo(i){ index = (i + slideEls.length) % slideEls.length; render(); resetTimer(); }

  function startTimer(){ if(conf.autoplay){ stopTimer(); timer = setInterval(next, conf.interval); } }
  function stopTimer(){ if(timer){ clearInterval(timer); timer = null; } }
  function resetTimer(){ stopTimer(); startTimer(); }

  nextBtn.addEventListener('click', ()=>{ next(); resetTimer(); });
  prevBtn.addEventListener('click', ()=>{ prev(); resetTimer(); });

  if(conf.pauseOnHover){
    viewport.addEventListener('mouseenter', ()=> stopTimer());
    viewport.addEventListener('mouseleave', ()=> startTimer());
  }

  if(conf.keyboard){
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowRight'){ next(); resetTimer(); }
      if(e.key === 'ArrowLeft'){ prev(); resetTimer(); }
    });
  }

  if(conf.touch){
    viewport.addEventListener('touchstart', (e)=>{ startX = e.touches[0].clientX; deltaX = 0; stopTimer(); }, {passive:true});
    viewport.addEventListener('touchmove', (e)=>{ deltaX = e.touches[0].clientX - startX; }, {passive:true});
    viewport.addEventListener('touchend', ()=>{ if(Math.abs(deltaX) > 50){ deltaX < 0 ? next() : prev(); } startTimer(); });
  }

  // progressive preloading: load current + next image for smoother transitions
  function preloadNearby(){
    [index, (index+1)%slideEls.length].forEach(i => {
      const img = slideEls[i].querySelector('img');
      if(img && !img.dataset.preloaded){
        const tmp = new Image();
        tmp.src = img.currentSrc || img.src;
        tmp.onload = ()=> img.dataset.preloaded = "1";
      }
    });
  }

  render();
  preloadNearby();
  startTimer();

  // update preload on slide change
  const observer = new MutationObserver(()=> preloadNearby());
  observer.observe(slidesEl, { attributes: true, subtree: true });

  // expose minimal API
  window.__heroSlider = { next, prev, goTo, startTimer, stopTimer };

})();
